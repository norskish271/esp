-- gamesense ESP + RMB Aimbot (2026 Enhanced Edition)
-- Optimized with better performance, organization, and features

local LibraryURL = "https://raw.githubusercontent.com/focat69/gamesense/refs/heads/main/source"
local Library = loadstring(game:HttpGetAsync(LibraryURL .. "?t=" .. tick()))()
local Window = Library:New({ Name = "gamesense | ESP & Aimbot", Padding = 8 })

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local WS = game:GetService("Workspace")
local LP = Players.LocalPlayer
local Cam = WS.CurrentCamera
local Mouse = LP:GetMouse()

-- Character handling
local Char, HRP
local function UpdateCharacter()
    Char = LP.Character
    if Char then
        HRP = Char:WaitForChild("HumanoidRootPart", 5)
    end
end

LP.CharacterAdded:Connect(function(newChar)
    Char = newChar
    HRP = newChar:WaitForChild("HumanoidRootPart", 8)
end)
UpdateCharacter()

-- Settings
local Settings = {
    ESP_Enabled = false,
    tracers = false,
    healthbar = false,
    headdot = false,
    skeleton = false,
    chams = false,
    cornerbox = false,
    rainbow = false,
    teamcheck = true,
    visiblecheck = false,
    distlimit = 1500,
    fovcircle = true,
    fovsize = 180,
    smoothness = 0.08,
    targetpart = "Head",
    aimbot = false,
    aimkey = Enum.UserInputType.MouseButton2,
    espupdate_rate = 0, -- 0 = every frame, higher = less frequent
}

-- Storage and connections
local ESP_Storage = {}
local Connections = {}
local lastESPUpdate = 0

-- FOV Circle
local FOV_Circle = Drawing.new("Circle")
FOV_Circle.Thickness = 1
FOV_Circle.NumSides = 64
FOV_Circle.Radius = Settings.fovsize
FOV_Circle.Filled = false
FOV_Circle.Transparency = 0.9
FOV_Circle.Color = Color3.fromRGB(50, 255, 120)
FOV_Circle.Visible = false

-- Rainbow color generator
local function GetRainbowColor()
    if not Settings.rainbow then return nil end
    local hue = (tick() * 0.5) % 1
    return Color3.fromHSV(hue, 0.8, 1)
end

-- Color utilities
local function GetHealthColor(health, maxHealth)
    local percentage = maxHealth > 0 and health / maxHealth or 0
    return Color3.fromHSV(percentage * 0.33, 0.9, 0.9)
end

local function GetTeamColor(plr, isVisible)
    if Settings.teamcheck and plr.Team == LP.Team then
        return Color3.fromRGB(80, 120, 255)
    end
    
    if not isVisible and Settings.visiblecheck then
        return Color3.fromRGB(100, 100, 100)
    end
    
    return Color3.fromRGB(255, 80, 80)
end

-- ESP Creation
local function NewESP(plr)
    if plr == LP or ESP_Storage[plr] then return end

    local drawings = {
        Box = Drawing.new("Square"),
        Tracer = Drawing.new("Line"),
        Name = Drawing.new("Text"),
        Distance = Drawing.new("Text"),
        HealthOuter = Drawing.new("Line"),
        HealthInner = Drawing.new("Line"),
        HeadDot = Drawing.new("Circle"),
    }
    
    -- Skeleton connections
    local skeletonConnections = {
        {"Head", "UpperTorso"},
        {"UpperTorso", "LowerTorso"},
        {"UpperTorso", "LeftUpperArm"},
        {"LeftUpperArm", "LeftLowerArm"},
        {"LeftLowerArm", "LeftHand"},
        {"UpperTorso", "RightUpperArm"},
        {"RightUpperArm", "RightLowerArm"},
        {"RightLowerArm", "RightHand"},
        {"LowerTorso", "LeftUpperLeg"},
        {"LeftUpperLeg", "LeftLowerLeg"},
        {"LeftLowerLeg", "LeftFoot"},
        {"LowerTorso", "RightUpperLeg"},
        {"RightUpperLeg", "RightLowerLeg"},
        {"RightLowerLeg", "RightFoot"},
    }
    
    for i, _ in ipairs(skeletonConnections) do
        drawings["Skel_" .. i] = Drawing.new("Line")
    end

    -- Box setup
    local b = drawings.Box
    b.Thickness = 1
    b.Filled = false
    b.Transparency = 1
    b.ZIndex = 2
    b.Visible = false

    -- Tracer
    local t = drawings.Tracer
    t.Thickness = 1
    t.Transparency = 0.7
    t.ZIndex = 1
    t.Visible = false

    -- Texts
    local n = drawings.Name
    n.Size = 14
    n.Center = true
    n.Outline = true
    n.OutlineColor = Color3.new(0, 0, 0)
    n.ZIndex = 3
    n.Visible = false
    
    local d = drawings.Distance
    d.Size = 12
    d.Center = true
    d.Outline = true
    d.OutlineColor = Color3.new(0, 0, 0)
    d.ZIndex = 3
    d.Visible = false

    -- Health bars
    local ho = drawings.HealthOuter
    ho.Thickness = 3
    ho.Color = Color3.new(0, 0, 0)
    ho.Transparency = 1
    ho.ZIndex = 2
    ho.Visible = false
    
    local hi = drawings.HealthInner
    hi.Thickness = 1
    hi.Transparency = 1
    hi.ZIndex = 3
    hi.Visible = false

    -- Head dot
    local hd = drawings.HeadDot
    hd.Radius = 4
    hd.NumSides = 12
    hd.Filled = true
    hd.Transparency = 1
    hd.ZIndex = 3
    hd.Visible = false

    -- Skeleton lines
    for i = 1, #skeletonConnections do
        local line = drawings["Skel_" .. i]
        line.Thickness = 1.5
        line.Transparency = 0.9
        line.ZIndex = 1
        line.Visible = false
    end

    -- Chams (Highlight)
    local highlight = Instance.new("Highlight")
    highlight.Enabled = false
    highlight.FillColor = Color3.fromRGB(255, 80, 80)
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Adornee = nil

    ESP_Storage[plr] = {
        drawings = drawings,
        highlight = highlight,
        skeletonConnections = skeletonConnections
    }
end

-- ESP Removal
local function RemoveESP(plr)
    local data = ESP_Storage[plr]
    if not data then return end
    
    for _, drawing in pairs(data.drawings) do
        if drawing and drawing.Remove then
            drawing:Remove()
        end
    end
    
    if data.highlight then
        data.highlight:Destroy()
    end
    
    ESP_Storage[plr] = nil
end

-- Corner Box Drawing
local function DrawCornerBox(pos, width, height, thickness, color, drawings)
    local corners = {
        -- Top left
        {from = pos, to = pos + Vector2.new(width * 0.3, 0)},
        {from = pos, to = pos + Vector2.new(0, height * 0.3)},
        -- Top right
        {from = pos + Vector2.new(width, 0), to = pos + Vector2.new(width - width * 0.3, 0)},
        {from = pos + Vector2.new(width, 0), to = pos + Vector2.new(width, height * 0.3)},
        -- Bottom left
        {from = pos + Vector2.new(0, height), to = pos + Vector2.new(width * 0.3, height)},
        {from = pos + Vector2.new(0, height), to = pos + Vector2.new(0, height - height * 0.3)},
        -- Bottom right
        {from = pos + Vector2.new(width, height), to = pos + Vector2.new(width - width * 0.3, height)},
        {from = pos + Vector2.new(width, height), to = pos + Vector2.new(width, height - height * 0.3)}
    }
    
    -- Use existing drawings or create temporary ones
    for i = 1, 8 do
        local line = drawings["Corner_" .. i] or Drawing.new("Line")
        line.Thickness = thickness
        line.Color = color
        line.From = corners[i].from
        line.To = corners[i].to
        line.Visible = true
        drawings["Corner_" .. i] = line
    end
end

-- ESP Update
local function UpdateAllESP()
    if not Settings.ESP_Enabled or not HRP then return end
    
    local currentTime = tick()
    if Settings.espupdate_rate > 0 and currentTime - lastESPUpdate < Settings.espupdate_rate then
        return
    end
    lastESPUpdate = currentTime
    
    local screenCenter = Vector2.new(Cam.ViewportSize.X / 2, Cam.ViewportSize.Y / 2)
    local rainbowCol = GetRainbowColor()

    for plr, data in pairs(ESP_Storage) do
        local char = plr.Character
        if not char then 
            for _, drawing in pairs(data.drawings) do
                drawing.Visible = false
            end
            data.highlight.Enabled = false
            continue 
        end

        local root = char:FindFirstChild("HumanoidRootPart")
        local hum = char:FindFirstChild("Humanoid")
        local head = char:FindFirstChild("Head")

        if not (root and hum and head and hum.Health > 0) then
            for _, drawing in pairs(data.drawings) do
                drawing.Visible = false
            end
            data.highlight.Enabled = false
            continue
        end

        local dist = (HRP.Position - root.Position).Magnitude
        if dist > Settings.distlimit then
            for _, drawing in pairs(data.drawings) do
                drawing.Visible = false
            end
            data.highlight.Enabled = false
            continue
        end

        local rootPos, onScreen = Cam:WorldToViewportPoint(root.Position)
        if not onScreen then
            for _, drawing in pairs(data.drawings) do
                drawing.Visible = false
            end
            data.highlight.Enabled = false
            continue
        end

        -- Visibility check
        local isVisible = true
        if Settings.visiblecheck then
            local raycastParams = RaycastParams.new()
            raycastParams.FilterDescendantsInstances = {Char}
            raycastParams.FilterType = Enum.RaycastFilterType.Exclude
            local rayResult = WS:Raycast(Cam.CFrame.Position, (root.Position - Cam.CFrame.Position).Unit * dist, raycastParams)
            isVisible = rayResult and rayResult.Instance:IsDescendantOf(char) or false
        end

        local color = rainbowCol or GetTeamColor(plr, isVisible)
        
        -- Calculate box dimensions
        local top = Cam:WorldToViewportPoint(root.Position + Vector3.new(0, 3, 0))
        local bottom = Cam:WorldToViewportPoint(root.Position - Vector3.new(0, 4, 0))
        local height = math.abs(top.Y - bottom.Y)
        local width = height * 0.55
        local position = Vector2.new(top.X - width / 2, top.Y)

        -- Update drawings
        local drawings = data.drawings
        
        -- Box / Corner Box
        if Settings.cornerbox then
            drawings.Box.Visible = false
            DrawCornerBox(position, width, height, 2, color, drawings)
        else
            -- Hide corner lines if they exist
            for i = 1, 8 do
                if drawings["Corner_" .. i] then
                    drawings["Corner_" .. i].Visible = false
                end
            end
            
            drawings.Box.Size = Vector2.new(width, height)
            drawings.Box.Position = position
            drawings.Box.Color = color
            drawings.Box.Visible = true
        end

        -- Name
        drawings.Name.Text = plr.Name
        drawings.Name.Position = Vector2.new(position.X + width / 2, position.Y - 20)
        drawings.Name.Color = color
        drawings.Name.Visible = true

        -- Distance
        drawings.Distance.Text = string.format("%d studs", math.floor(dist))
        drawings.Distance.Position = Vector2.new(position.X + width / 2, position.Y + height + 4)
        drawings.Distance.Color = color
        drawings.Distance.Visible = true

        -- Tracer
        drawings.Tracer.From = screenCenter
        drawings.Tracer.To = Vector2.new(position.X + width / 2, position.Y + height)
        drawings.Tracer.Color = color
        drawings.Tracer.Visible = Settings.tracers

        -- Health Bar
        if Settings.healthbar then
            local healthPercentage = hum.MaxHealth > 0 and (hum.Health / hum.MaxHealth) or 0
            local healthBarHeight = height * healthPercentage
            
            drawings.HealthOuter.From = Vector2.new(position.X - 6, position.Y)
            drawings.HealthOuter.To = Vector2.new(position.X - 6, position.Y + height)
            drawings.HealthOuter.Visible = true
            
            drawings.HealthInner.From = Vector2.new(position.X - 6, position.Y + height - healthBarHeight)
            drawings.HealthInner.To = Vector2.new(position.X - 6, position.Y + height)
            drawings.HealthInner.Color = GetHealthColor(hum.Health, hum.MaxHealth)
            drawings.HealthInner.Visible = true
        else
            drawings.HealthOuter.Visible = false
            drawings.HealthInner.Visible = false
        end

        -- Head Dot
        local headPos = Cam:WorldToViewportPoint(head.Position)
        drawings.HeadDot.Position = Vector2.new(headPos.X, headPos.Y)
        drawings.HeadDot.Color = color
        drawings.HeadDot.Visible = Settings.headdot

        -- Skeleton
        if Settings.skeleton then
            for i, connection in ipairs(data.skeletonConnections) do
                local part1 = char:FindFirstChild(connection[1])
                local part2 = char:FindFirstChild(connection[2])
                
                if part1 and part2 then
                    local pos1, visible1 = Cam:WorldToViewportPoint(part1.Position)
                    local pos2, visible2 = Cam:WorldToViewportPoint(part2.Position)
                    
                    if visible1 and visible2 then
                        local line = drawings["Skel_" .. i]
                        line.From = Vector2.new(pos1.X, pos1.Y)
                        line.To = Vector2.new(pos2.X, pos2.Y)
                        line.Color = color
                        line.Visible = true
                    else
                        drawings["Skel_" .. i].Visible = false
                    end
                else
                    drawings["Skel_" .. i].Visible = false
                end
            end
        else
            for i = 1, #data.skeletonConnections do
                drawings["Skel_" .. i].Visible = false
            end
        end

        -- Chams
        data.highlight.Adornee = char
        data.highlight.FillColor = color
        data.highlight.OutlineColor = Color3.new(color.R * 0.5, color.G * 0.5, color.B * 0.5)
        data.highlight.Enabled = Settings.chams
    end
end

-- Aimbot System
local Aiming = false
UIS.InputBegan:Connect(function(input)
    if input.UserInputType == Settings.aimkey then
        Aiming = true
    end
end)

UIS.InputEnded:Connect(function(input)
    if input.UserInputType == Settings.aimkey then
        Aiming = false
    end
end)

local function GetClosestTarget()
    local center = Vector2.new(Cam.ViewportSize.X / 2, Cam.ViewportSize.Y / 2)
    local bestTarget, bestDistance = nil, Settings.fovsize

    for _, player in Players:GetPlayers() do
        if player == LP then continue end
        if Settings.teamcheck and player.Team == LP.Team then continue end
        
        local character = player.Character
        if not character then continue end
        
        local humanoid = character:FindFirstChild("Humanoid")
        if not humanoid or humanoid.Health <= 0 then continue end
        
        local targetPart = character:FindFirstChild(Settings.targetpart)
        if not targetPart then continue end
        
        local screenPosition, onScreen = Cam:WorldToViewportPoint(targetPart.Position)
        if not onScreen then continue end
        
        local screenPos = Vector2.new(screenPosition.X, screenPosition.Y)
        local distance = (screenPos - center).Magnitude
        
        if distance < bestDistance then
            bestDistance = distance
            bestTarget = targetPart
        end
    end
    
    return bestTarget
end

local function AimAtTarget()
    if not Settings.aimbot or not Aiming then return end
    
    local target = GetClosestTarget()
    if not target then return end
    
    local targetPosition = target.Position
    local screenPosition, onScreen = Cam:WorldToViewportPoint(targetPosition)
    
    if not onScreen then return end
    
    local center = Vector2.new(Cam.ViewportSize.X / 2, Cam.ViewportSize.Y / 2)
    local delta = Vector2.new(screenPosition.X, screenPosition.Y) - center
    
    -- Apply smoothing
    local smoothedDelta = delta * (1 - Settings.smoothness)
    
    -- Move mouse
    mousemoverel(smoothedDelta.X, smoothedDelta.Y)
end

-- Main loop
Connections.MainLoop = RunService.RenderStepped:Connect(function()
    pcall(function()
        -- Update FOV circle
        FOV_Circle.Position = Vector2.new(Cam.ViewportSize.X / 2, Cam.ViewportSize.Y / 2)
        FOV_Circle.Radius = Settings.fovsize
        FOV_Circle.Visible = Settings.fovcircle and Settings.aimbot
        
        -- Update ESP
        UpdateAllESP()
        
        -- Run aimbot
        AimAtTarget()
    end)
end)

-- Cleanup function
local function Cleanup()
    for _, connection in pairs(Connections) do
        connection:Disconnect()
    end
    
    FOV_Circle:Remove()
    
    for plr, _ in pairs(ESP_Storage) do
        RemoveESP(plr)
    end
    
    ESP_Storage = {}
    Connections = {}
end

-- UI Setup
local ESPTab = Window:CreateTab({Name = "ESP"})
local AimTab = Window:CreateTab({Name = "Aimbot"})
local SettingsTab = Window:CreateTab({Name = "Settings"})

-- ESP Tab
ESPTab:Toggle({Name = "ESP Enabled", State = false, Callback = function(state)
    Settings.ESP_Enabled = state
    
    if state then
        -- Create ESP for existing players
        for _, player in Players:GetPlayers() do
            NewESP(player)
        end
        
        -- Connect player added event
        Connections.PlayerAdded = Players.PlayerAdded:Connect(function(player)
            NewESP(player)
        end)
        
        -- Connect player removing event
        Connections.PlayerRemoving = Players.PlayerRemoving:Connect(function(player)
            RemoveESP(player)
        end)
    else
        -- Cleanup connections and ESP
        if Connections.PlayerAdded then
            Connections.PlayerAdded:Disconnect()
        end
        if Connections.PlayerRemoving then
            Connections.PlayerRemoving:Disconnect()
        end
        
        for plr, _ in pairs(ESP_Storage) do
            RemoveESP(plr)
        end
        ESP_Storage = {}
    end
end})

ESPTab:Toggle({Name = "Tracers", State = false, Callback = function(state) Settings.tracers = state end})
ESPTab:Toggle({Name = "Health Bar", State = false, Callback = function(state) Settings.healthbar = state end})
ESPTab:Toggle({Name = "Head Dot", State = false, Callback = function(state) Settings.headdot = state end})
ESPTab:Toggle({Name = "Skeleton ESP", State = false, Callback = function(state) Settings.skeleton = state end})
ESPTab:Toggle({Name = "Chams (Highlight)", State = false, Callback = function(state) Settings.chams = state end})
ESPTab:Toggle({Name = "Corner Box", State = false, Callback = function(state) Settings.cornerbox = state end})
ESPTab:Toggle({Name = "Rainbow Mode", State = false, Callback = function(state) Settings.rainbow = state end})
ESPTab:Toggle({Name = "Team Check", State = true, Callback = function(state) Settings.teamcheck = state end})
ESPTab:Toggle({Name = "Visible Only", State = false, Callback = function(state) Settings.visiblecheck = state end})

ESPTab:Slider({Name = "Max Distance", Min = 100, Max = 10000, Default = 1500, Callback = function(value)
    Settings.distlimit = value
end})

-- Aimbot Tab
AimTab:Toggle({Name = "Aimbot (Hold RMB)", State = false, Callback = function(state) Settings.aimbot = state end})
AimTab:Toggle({Name = "Draw FOV Circle", State = true, Callback = function(state) Settings.fovcircle = state end})
AimTab:Slider({Name = "FOV Size", Min = 25, Max = 1000, Default = 180, Callback = function(value)
    Settings.fovsize = value
end})
AimTab:Slider({Name = "Smoothness", Min = 0.01, Max = 0.5, Default = 0.08, Step = 0.01, Callback = function(value)
    Settings.smoothness = value
end})
AimTab:Dropdown({Name = "Aim Part", Items = {"Head", "HumanoidRootPart", "UpperTorso"}, Default = "Head", Callback = function(value)
    Settings.targetpart = value
end})

-- Settings Tab
SettingsTab:Button({Name = "Cleanup ESP", Callback = function()
    for plr, _ in pairs(ESP_Storage) do
        RemoveESP(plr)
    end
    ESP_Storage = {}
    Library:Notify({Description = "ESP cleaned up", Duration = 3})
end})

SettingsTab:Button({Name = "Refresh Character", Callback = function()
    UpdateCharacter()
    Library:Notify({Description = "Character reference refreshed", Duration = 3})
end})

-- Initialization
for _, player in Players:GetPlayers() do
    if player ~= LP then
        NewESP(player)
    end
end

-- Game cleanup
game:GetService("Unloading"):Connect(Cleanup)

Library:Notify({Description = "Enhanced ESP & Aimbot loaded | Hold RMB to aim | No prediction", Duration = 6})
print("Enhanced gamesense loaded - Better performance, more features")
